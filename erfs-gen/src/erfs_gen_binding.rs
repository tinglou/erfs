/* automatically generated by rust-bindgen */

pub const ErfsGenOption_ERFS_GEN_GZIPPED: ErfsGenOption = 2;
pub const ErfsGenOption_ERFS_GEN_RUST: ErfsGenOption = 4;
pub type ErfsGenOption = u32;
pub const ErfsGenStatusCode_ERFS_GEN_OK: ErfsGenStatusCode = 0;
pub const ErfsGenStatusCode_ERFS_INVALID_INPUT: ErfsGenStatusCode = -1;
pub const ErfsGenStatusCode_ERFS_NOT_FOUND: ErfsGenStatusCode = -2;
pub const ErfsGenStatusCode_ERFS_NOT_FILE: ErfsGenStatusCode = -3;
pub const ErfsGenStatusCode_ERFS_NOT_DIRECTORY: ErfsGenStatusCode = -4;
pub const ErfsGenStatusCode_ERFS_OUTOF_BOUND: ErfsGenStatusCode = -5;
pub const ErfsGenStatusCode_ERFS_SOURCE_TOO_LARGE: ErfsGenStatusCode = -100;
pub const ErfsGenStatusCode_ERFS_TARGET_NOT_EXIST: ErfsGenStatusCode = -101;
pub const ErfsGenStatusCode_ERFS_INVALID_ID: ErfsGenStatusCode = -102;
pub const ErfsGenStatusCode_ERFS_INVALID_OPTION: ErfsGenStatusCode = -103;
#[doc = ""]
#[doc = " status code of access api"]
#[doc = ""]
pub type ErfsGenStatusCode = i32;
extern "C" {
    #[doc = ""]
    #[doc = " generate ERFS source file"]
    #[doc = "@param path the directory or file to be embedded"]
    #[doc = "@param id identity of the FS, format: [a-z][a-z_0-9]*"]
    #[doc = "@param option e.g. gzip text files"]
    #[doc = "@param target_dir target directory"]
    pub fn erfs_generate(
        path: *const ::std::os::raw::c_char,
        id: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
        target_dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
